package com.assessment.ekos.service;import com.assessment.ekos.base.AbstractEntityService;import com.assessment.ekos.base.BaseRepository;import com.assessment.ekos.dto.LoginDto;import com.assessment.ekos.dto.TokenDto;import com.assessment.ekos.dto.UserDto;import com.assessment.ekos.exeption.BadRequestException;import com.assessment.ekos.mapper.UserMapper;import com.assessment.ekos.model.User;import com.assessment.ekos.repository.UserRepository;import com.assessment.ekos.resource.UserResource;import com.assessment.ekos.security.UserDetailsImpl;import com.assessment.ekos.util.MessageUtil;import io.micrometer.common.util.StringUtils;import lombok.RequiredArgsConstructor;import org.springframework.http.ResponseEntity;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.Optional;@RequiredArgsConstructor@Servicepublic class UserService extends AbstractEntityService<User, Long> {    private final AuthenticationManager authenticationManager;    private final PasswordEncoder encoder;    private final UserMapper mapper;    private final UserMapper userMapper;    private final UserRepository userRepository;    private final UserResource userResource;    private AuthorizationService authorizationService;    public ResponseEntity<?> createEkosUser(UserDto userDto) {        var ekosUser = mapper.toEntity(userDto);        ekosUser.setPassword(encoder.encode(userDto.getPassword()));        ekosUser = userRepository.save(ekosUser);        return ResponseEntity.ok(ekosUser);    }    public User save(UserDto userDto) {        User user = userMapper.toEntity(userDto);        checkUser(user);        user.setPassword(encoder.encode(user.getPassword()));        return super.save(user);    }    private void checkUser(User entity) {        if (StringUtils.isBlank(entity.getEmail())) {            throw new BadRequestException(MessageUtil.EMAIL_ERROR.getKey());        }        if (StringUtils.isBlank(entity.getPassword())) {            throw new BadRequestException(MessageUtil.PASSWORD_ERROR.getKey());        }    }    public ResponseEntity<?> authenticateUser(LoginDto loginDto) {        Optional<User> user = userRepository.findOneByEmail(loginDto.getEmail());        if (user.isPresent() && encoder.matches(loginDto.getPassword(), user.get().getPassword())) {            Authentication authentication =                    authenticationManager.authenticate(                            new UsernamePasswordAuthenticationToken(loginDto.getEmail(), loginDto.getPassword()));            SecurityContextHolder.getContext().setAuthentication(authentication);            String jwt = this.authorizationService.getJWTToken(user.get());            UserDto userDto = mapper.toDto(user.get());            TokenDto tokenDto = new TokenDto();            tokenDto.setToken(jwt);            userDto.setTokenDto(tokenDto);            return ResponseEntity.ok(userDto);        } else {            throw new BadRequestException(MessageUtil.USER_NOT_FOUND.getKey());        }    }    @Transactional    public UserDetails loadUserByEmail(String email) throws UsernameNotFoundException {        Optional<User> user = userRepository.findOneByEmail(email);        if (user.isPresent()) {            return UserDetailsImpl.build(user.get());        }        throw new BadRequestException(MessageUtil.EMAIL_ERROR.getKey());    }    @Override    public BaseRepository<User, Long> getRepository() {        return userRepository;    }}